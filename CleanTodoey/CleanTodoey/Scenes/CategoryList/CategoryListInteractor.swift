//
//  CategoryListInteractor.swift
//  CleanTodoey
//
//  Created by Jo√£o Pedro Giarrante on 25/10/20.
//  Copyright (c) 2020 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol CategoryListBusinessLogic {
    func fetchCategories()
    func updateCategories(with request: CategoryList.UpdateCategories.Request)
}

protocol CategoryListDataStore {
    var categories: Array<Category>? { get set }
}

class CategoryListInteractor: CategoryListBusinessLogic, CategoryListDataStore {
    var categories: Array<Category>? = []
    

    // MARK: Properties
    
    var presenter: CategoryListPresentationLogic?
    var worker: CategoryListWorker?
    
    
    // MARK: Fetch Categories
    
    func fetchCategories() {
        worker = CategoryListWorker()
        worker?.fetchCategories()
            .done(handleFetchCategories)
    }
    
    private func handleFetchCategories(response: CategoryList.FetchCategories.Response){
        if let categories: Array<Category> = response.categories?.toArray(type: Category.self) {
            self.categories = categories
        }
        presenter?.presentCategories(response)
    }
    
    
    // MARK: Update Categories
    
    func updateCategories(with request: CategoryList.UpdateCategories.Request) {
        worker = CategoryListWorker()
        worker?.updateCategories(with: request)
            .done(handleUpdateCategoriesSuccess)
            .catch(handleUpdateCategoriesError)
    }
    
    private func handleUpdateCategoriesSuccess(response: CategoryList.UpdateCategories.Response){
        if let category = response.addedCategory {
            categories?.append(category)
        } else if let category = response.removedCategory, let correctIndex = categories?.firstIndex(of: category) {
            categories?.remove(at: correctIndex)
        }
        let finalResponse = CategoryList.UpdateCategories.Response(categories:self.categories, error: response.error)
        presenter?.presentUpdateCategories(finalResponse)
    }
    
    private func handleUpdateCategoriesError(error: Error){
        let response = CategoryList.UpdateCategories.Response(error: error)
        presenter?.presentUpdateCategories(response)
    }
}
